package com.mosaicsheep.sort.shellsort;

import java.util.Arrays;

// 在希尔排序时，每次按照增量分组完毕后，对于每一组的数据进行排序时，
// 可以采用：
// 1. 交换法
// 2. 移动法
// 本例中使用的是交换的方式，类似于增强版冒泡排序
// 即，对分组后的每组数据采用冒泡排序，只不过，
// 这种冒泡是穿插性的，是跳着比，不是连续比
public class ShellSort1Verbose {
    public static void main(String[] args) {
        // 由小到大进行排序
        int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0};// 数据量(length)为10
        int temp = 0;// 用于交换的临时变量

        // 第一轮排序
        // 将10个数据分成 10/2 = 5组（arr.length/2）
        // 每组有两个元素，对这两组分别进行插入排序
        // 对n个元素进行冒泡排序的话，共应该循环(n-1)次
        // 外层循环：组数 * 每组进行冒泡排序的次数，即总的排序次数
        // 为什么外层循环要用总的排序次数？这和内层循环的循环退出条件有关
        // 实际上，步长减组数的退出条件，使得每一次的内层循环都只进行了一次。
        for (int i = 5; i < arr.length; i++) {// 共5组，每组2个元素进行冒泡排序，应该循环5*(2-1) = 5次

            for (int j = i - 5; j >= 0; j -= 5) {// 共5组，因此步长要减5
                // 第一次进来时，开始比较第一组数据
                // 此时，j = 5 - 5 = 0， j + 5 = 5
                // 即，比较arr[0]和arr[5]
                // 如果当前元素(arr[0]) 大于 加上步长后的那个元素(arr[5])，说明需要交换
                if (arr[j] > arr[j + 5]) {
                    temp = arr[j];
                    arr[j] = arr[j + 5];
                    arr[j + 5] = temp;
                }

            }
        }
        System.out.println("第一轮排序结果：" + Arrays.toString(arr));

        System.out.println("---------------------------------------------------------");

        // 第二轮排序
        // 将10个数据分成 10/2^2 = 2组（length/2^2）
        // 每组有5个元素，对这两组进行插入排序
        for (int i = 2; i < arr.length; i++) {// 共2组，每组5个元素进行插叙排序，共应该循环2*(5-1)= 8次

            for (int j = i - 2; j >= 0; j -= 2) {// 共2组，因此步长要减2，从而使每一次的内层循环都只进行了一次
                // 第一次进来时，开始比较第一组数据的前两个数据
                // 此时，j = 2 - 2 = 0， j + 2 = 2
                // 即，比较arr[0]和arr[2]
                // 如果当前元素(arr[0]) 大于 加上步长后的那个元素(arr[2])，说明需要交换
                if (arr[j] > arr[j + 2]) {
                    temp = arr[j];
                    arr[j] = arr[j + 2];
                    arr[j + 2] = temp;
                }

            }
        }
        System.out.println("第二轮排序结果：" + Arrays.toString(arr));

        System.out.println("---------------------------------------------------------");

        // 第三轮排序
        // 将10个数据分成 10/2^3 = 1组
        // 对这元素组进行插入排序
        for (int i = 1; i < arr.length; i++) {// 共应该循环(10-1)= 9次

            for (int j = i - 1; j >= 0; j -= 1) {// 共1组，因此步长要减1
                // 第一次进来时，开始比较第一组数据
                // 此时，j = 1 - 1 = 0， j + 1 = 1
                // 即，比较arr[0]和arr[1]
                // 如果当前元素(arr[0]) 大于 加上步长后的那个元素(arr[1])，说明需要交换
                if (arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }

            }
        }
        System.out.println("第三轮排序结果：" + Arrays.toString(arr));

    }
}
